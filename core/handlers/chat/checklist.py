from aiogram import Dispatcher, Botfrom aiogram.types import (Message, InlineKeyboardButton, InlineKeyboardMarkup,                           CallbackQuery, ContentType)from aiogram.dispatcher import FSMContextfrom core.custom_filters import SeparatorFilterfrom aides.openai.ai_analyzer import send_analyzed_reportCNT_LOCATION = 5CHECKLIST = {    "location_1": ["–ö—É—Ö–Ω—è", "–ö–æ—Ä–∏–¥–æ—Ä", "–°–ø–∞–ª—å–Ω—è", "–ó–∞–ª", "–í–±–∏—Ä–∞–ª—å–Ω—è"],    "location_2": ["–ö–æ—Ä–∏–¥–æ—Ä", "–ë–∞–ª–∫–æ–Ω", "–°–ø–∞–ª—å–Ω—è", "–ö–∞–±—ñ–Ω–µ—Ç", "–î–∏—Ç—è—á—è"],    "location_3": ["–ö–∞–±—ñ–Ω–µ—Ç ‚Ññ1", "–ö–∞–±—ñ–Ω–µ—Ç ‚Ññ2", "–ö–∞–±—ñ–Ω–µ—Ç ‚Ññ3", "–ö—É—Ö–Ω—è",                   "–í–±–∏—Ä–∞–ª—å–Ω—è"],    "location_4": ["–ö–æ–º–æ—Ä–∞", "–ö—É—Ö–Ω—è", "–ó–∞–ª", "–†–æ–∑–≤–∞–∂–∞–ª—å–Ω–∞", "–†–æ–∑–¥—è–≥–∞–ª—å–Ω—è"],    "location_5": ["–ö—É—Ö–Ω—è", "–°—Ç–æ–ª–æ–≤–∞", "–°–ø–∞–ª—å–Ω—è", "–ü—Ä–∏—Ö–æ–∂–∞", "–ö–æ—Ä–∏–¥–æ—Ä"]}async def handler_checklist(msg: Message, state: FSMContext):    keyboards = InlineKeyboardMarkup()    for key in CHECKLIST.keys():        keyboards.add(InlineKeyboardButton(            text=f'–õ–æ–∫–∞—Ü—ñ—è {key[9:]}',            callback_data=key        ))    await msg.answer('–û–±–µ—Ä—ñ—Ç—å –æ–¥–Ω—É –∑ –ª–æ–∫–∞—Ü—ñ–π', reply_markup=keyboards)    await state.update_data(started=True)async def handler_location(cb: CallbackQuery, state: FSMContext):    """    Handles the callback query for selecting a location and presents a    checklist of items related to that location.    Args:        cb (types.CallbackQuery): The callback query object containing the        data of the selected location.        state (FSMContext): The FSM (finite state machine) context for        handling user state.    Returns:        None    """    # Checking if the conversation has been started    data = await state.get_data("started")    if not data.get("started"):        return    location = cb.data    bot = Bot.get_current()    await bot.answer_callback_query(cb.id)    keyboard = InlineKeyboardMarkup()    for i in CHECKLIST[location]:        keyboard.add(InlineKeyboardButton(            text=f"{i}",            callback_data=f"room_{i}")        )    keyboard.add(InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back"))    await cb.message.reply(        text='–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—É–Ω–∫—Ç–∏!',        reply_markup=keyboard    )    await state.update_data(location=location)async def handler_room(cb: CallbackQuery, state: FSMContext):    """     Handles the callback query for selecting a room and presents options to     mark it as clean or leave a comment.     Args:         cb (types.CallbackQuery): The callback query object containing the         data of the selected room.         state (FSMContext): The FSM (finite state machine) context         for handling user state.     Returns:         None     """    bot = Bot.get_current()    await bot.answer_callback_query(cb.id)    room = cb.data    keyboard = InlineKeyboardMarkup()    keyboard.add(InlineKeyboardButton(        text="‚úÖ –í—Å–µ —á–∏—Å—Ç–æ",        callback_data=f"clear_{room}")    )    keyboard.add(InlineKeyboardButton(        text="üìÑ –ó–∞–ª–∏—à–∏—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä",        callback_data=f"comment_{room}")    )    await cb.message.reply(        text=("–í–∏–±–µ—Ä—ñ—Ç—å '–í—Å–µ —á–∏—Å—Ç–æ', —è–∫—â–æ –Ω–µ–º–∞—î –∑–∞—É–≤–∞–∂–µ–Ω—å, "              "–∞–±–æ –¥–æ–¥–∞–π—Ç–µ –∫–æ–º–µ–Ω—Ç–∞—Ä..."),        reply_markup=keyboard    )    await state.update_data(room=room[5:])async def handler_clear(cb: CallbackQuery, state: FSMContext):    """    Handles the callback query for marking a room as clean and updates the    state accordingly.    Args:        cb (types.CallbackQuery): The callback query object containing the        data of the selected room.        state (FSMContext): The FSM (finite state machine) context for handling        user state.    Returns:        None    """    state_data = await state.get_data()    location_data = state_data.get("location", None)    room = state_data.get("room", None)    # Updating the state with the clean status for the selected room    location_comments = state_data.get(location_data, {})    location_comments[room] = "–í—Å–µ —á–∏—Å—Ç–æ!"    await state.update_data({location_data: location_comments})    keyboard = InlineKeyboardMarkup()    if len(location_comments) == 5:        keyboard.add(InlineKeyboardButton(            text="–°—Ñ–æ—Ä–º—É–≤–∞—Ç–∏ –∑–≤—ñ—Ç! üìã",            callback_data="report")        )    keyboard.add(InlineKeyboardButton(        text="–ù–∞–∑–∞–¥",        callback_data=location_data)    )    # Sending a confirmation message with options to proceed or go back    await cb.message.reply(        text=f"–î—è–∫—É—é, —É—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!: {location_comments}",        reply_markup=keyboard    )async def handler_photo_message(msg: Message, state: FSMContext):    """    Handles the photo message input and updates the state with the photo link.    Args:        msg (types.Message): The message object containing the photo.        state (FSMContext): The FSM (finite state machine) context for        handling user state.    Returns:        None    """    # Retrieving data from the state    data = await state.get_data()    # Checking if a photo is expected    if not data.get("photo_true", None):        return    # Extracting the photo ID and constructing the photo link    photo_id = msg.photo[-1].file_id    photo_link = f"t.me/{msg.chat.username}?photo={photo_id}"    # Retrieving additional state data    state_data = await state.get_data()    location_data = state_data.get("location")    room = state_data.get("room")    # Updating the state with the photo link for the selected room    location_comments = state_data.get(location_data, {})    location_comments[room] += f" {photo_link}"    await state.update_data({location_data: location_comments})    await state.update_data(started=True)    # Generating inline keyboard buttons    keyboard = InlineKeyboardMarkup()    if len(location_comments) == 5:        keyboard.add(InlineKeyboardButton(            text="–°—Ñ–æ—Ä–º—É–≤–∞—Ç–∏ –∑–≤—ñ—Ç! üìã",            callback_data="report")        )    keyboard.add(InlineKeyboardButton(        text="–ù–∞–∑–∞–¥",        callback_data=location_data)    )    # Sending a confirmation message with options to proceed or go back    await msg.reply(        text=f"–§–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é —Ç–∞ –∫–æ–º–µ–Ω—Ç–∞—Ä —É—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ! {location_comments}",        reply_markup=keyboard    )async def handler_comment(cb: CallbackQuery, state: FSMContext):    await state.update_data(message=True)    await state.update_data(query=cb)    # Acknowledging the callback query    bot = Bot.get_current()    await bot.answer_callback_query(cb.id)    # Asking the user to leave a comment    await cb.message.reply("–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ª–∏—à—Ç–µ –∫–æ–º–µ–Ω—Ç–∞—Ä:")async def handler_text_message(msg: Message, state: FSMContext):    """    Handles the photo message input and updates    the state with the photo link.    Args:       msg (types.Message): The message object containing the photo.       state (FSMContext): The FSM (finite state machine) context        for handling user state.    Returns:       None    """    # Retrieving data from the state    data = await state.get_data()    # Checking if a message is expected    if not data.get("message"):        return    # Extracting the comment from the message    comment = msg.text    # Retrieving additional state data    state_data = await state.get_data()    location_data = state_data.get("location", None)    room = state_data.get("room", None)    # Updating the state with the comment for the selected room    location_comments = state_data.get(location_data, {})    location_comments[room] = comment    await state.update_data({location_data: location_comments})    # Generating inline keyboard buttons    keyboard = InlineKeyboardMarkup()    keyboard.add(        InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data=location_data)    )    # Asking the user to upload a photo    await msg.reply(text=f"–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é:",                    reply_markup=keyboard)    # Updating the state to indicate that a photo is expected    await state.update_data(photo_true=True)    await state.update_data(message=False)async def handler_report(cb: CallbackQuery, state: FSMContext):    """    Handles the callback query to generate and send a report based on the    checklist entries.    Args:        cb (types.CallbackQuery): The callback query object containing the                                  request to generate a report.        state (FSMContext): The FSM (finite state machine)                            context for handling user state.       Returns:           None    """    # Acknowledging the callback query    bot = Bot.get_current()    await bot.answer_callback_query(cb.id)    # Retrieving data from the state    state_data = await state.get_data()    room = state_data.get("location")    location_rooms = state_data.get(room, {})    # Constructing the report based on checklist entries    report = "–ó–≤—ñ—Ç –∑–∞ —á–µ–∫-–ª–∏—Å—Ç:\n"    for room_name, status in location_rooms.items():        report += f"{room_name}: {status}\n"    keyboard = InlineKeyboardMarkup()    keyboard.add(InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back"))    report = await send_analyzed_report(report)    await cb.message.reply(f"{report}", reply_markup=keyboard)async def handler_back(cb: CallbackQuery, state: FSMContext):    bot = Bot.get_current()    await bot.answer_callback_query(cb.id)    await handler_checklist(cb.message, state)def register_handlers(dp: Dispatcher):    dp.register_message_handler(        handler_checklist,        commands=['checklist', 'c']    )    dp.register_message_handler(        handler_text_message,        lambda msg: msg.text and not msg.entities    )    dp.register_message_handler(        handler_photo_message,        content_types=ContentType.PHOTO    )    dp.register_callback_query_handler(        handler_location,        SeparatorFilter(separator='location_'),    )    dp.register_callback_query_handler(        handler_room,        SeparatorFilter(separator='room')    )    dp.register_callback_query_handler(        handler_clear,        SeparatorFilter(separator='clear')    )    dp.register_callback_query_handler(        handler_comment,        SeparatorFilter(separator='comment')    )    dp.register_callback_query_handler(        handler_comment,        SeparatorFilter(separator='back')    )    dp.register_callback_query_handler(        handler_report,        SeparatorFilter(separator='report')    )